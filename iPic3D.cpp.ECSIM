
#include <iomanip>
#include "iPic3D.h"

using namespace iPic3D;

int main(int argc, char **argv) {

  iPic3D::c_Solver KCode;
  bool b_err = false;

  
  /* ------------------------------ */
  /* 0- Initialize the solver class */
  /* ------------------------------ */

  KCode.Init(argc, argv);
    
  KCode.InjectBoundaryParticles();
  // without mlmd ops
  KCode.GatherMoments_Init();

  // added to compare with ECSIM    
  KCode.WriteOutput(KCode.FirstCycle());

  /* ------------ */
  /* 1- Main loop */
  /* ------------ */

  for (int i = KCode.FirstCycle()+1; i <= KCode.LastCycle(); i++) {
    /*! mlmd: KCode.get_myrank() is on the local grid communicator */
    if (KCode.get_myrank() == 0) cout << " ======= Grid " << KCode.get_numGrid()  <<"  Cycle " << i << " ======= " << endl;

    /* ----------------------------------------------------- */
    /* 2- Calculate fields and move particles                */
    /*    Exit if there is a memory issue with the particles */
    /* ----------------------------------------------------- */

    KCode.UpdateCycleInfo(i);

    // with mlmd ops
    if (!b_err) KCode.GatherMoments();

    if (!b_err) KCode.CalculateField_ECSIM(i);

    b_err = KCode.ParticlesMover(); 

    // particles have to be moved with En+theta, Bn
    // B n+1 calculated on the centers in CalculateField_ECSIM
    // the interpolation to the nodes (used to move particles)
    // is done after the mover
    KCode.interpBC2N_ECSIM(i);

    if ( b_err) i = KCode.LastCycle() + 1;

    /* --------------- */
    /* 3- Output files */
    /* --------------- */

    
    KCode.WriteOutput(i);
    KCode.WriteConserved(i);
    KCode.WriteRestart(i);
    
  }

  KCode.Finalize();

  return 0;
}
